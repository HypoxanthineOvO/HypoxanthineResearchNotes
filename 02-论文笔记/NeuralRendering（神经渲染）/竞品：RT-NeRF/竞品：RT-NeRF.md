---
tags:
  - NR
  - Co-Design
---

> [!important] Real-Time On-Device Neural Radiance Fields Towards Immersive AR/VR Rendering

# Abstract

基于神经辐射场（NeRF）的渲染由于其最先进的（SOTA）渲染质量和在增强和虚拟现实（AR/VR）中的广泛应用，已经吸引了越来越多的关注。然而，由于AR/VR设备上可实现的吞吐量较低，基于NeRF渲染的沉浸式实时（>30 FPS）互动仍然有限。为此，我们首先对商业设备上的SOTA高效的NeRF算法进行了剖析，并确定了上述低效率的两个主要原因：（1）均匀的点采样和（2）NeRF中所需嵌入的密集访问和计算。此外，我们提出了RT-NeRF，据我们所知，它是NeRF的第一个算法-硬件联合设计加速器。具体来说，在算法层面上，RT-NeRF集成了一个高效的渲染管道，通过直接计算预先存在的点的几何形状，在很大程度上缓解了NeRF中普遍采用的均匀点采样方法所带来的低效率。此外，RT-NeRF还利用了一个粗粒度的与视图相关的计算排序方案，以消除对不可见点的（不必要的）处理。在硬件层面上，我们提出的RT-NeRF加速器（1）采用混合编码方案，为NeRF的稀疏嵌入自适应地切换位图或基于坐标的稀疏编码格式，旨在最大限度地节省存储空间，从而减少所需的DRAM访问，同时支持高效的NeRF解码；以及（2）集成了一个双向加法器和搜索树以及一个高密度稀疏搜索单元来协调前述两种编码格式。在8个数据集上进行的广泛实验一致验证了RT-NeRF的有效性，与SOTA高效的NeRF解决方案相比，在保持渲染质量的同时实现了较大的吞吐量提升（例如9.7×∼3201×）。

# Introduction

新视图合成（见图1），即在一组稀疏采样的视图中渲染逼真的新颖视图，已经成为各种AR/VR应用的基本任务，如虚拟会议。因此，人们为提高可实现的渲染质量做出了巨大努力，其中基于NeRF的渲染由于其最先进的（SOTA）渲染质量，最近吸引了越来越多的关注。然而，尽管人们非常渴望基于NeRF渲染的沉浸式实时（> 30 FPS）互动，但由于目前在AR/VR设备上可实现的渲染吞吐量较低，例如，在SOTA GPU（如NVIDIA V100 GPU）上渲染800×800的图像< 0.04 FPS，所以它们还不可能实现。

为了弥补上述差距，我们首先对商业设备上的SOTA高效的NeRF算法进行了深入的分析，通过描述算法管道中每个步骤的运行时间来识别导致渲染效率低下的瓶颈。特别是，我们在SOTA高效NeRF算法的管道中找到了两个效率瓶颈步骤：（1）定位预先存在的点，即过滤掉代表空白空间的点；（2）计算预先存在的点的特征，即根据对应于特定网格的嵌入，生成预先存在的点的特征（即密度和颜色）。此外，我们发现这两个步骤的瓶颈效率低下，分别是由于（1）尽管存在点的稀疏性，但普遍采用统一的点采样方法；（2）尽管这些嵌入的稀疏性，但需要密集的访问和计算对应于特定网格的嵌入。

为了解决上述发现的低效率问题，我们提倡NeRF算法与硬件共同设计，以实现实时的设备上NeRF处理，实现沉浸式AR/VR渲染，并做出以下贡献：

- 我们全面地剖析了在多种商业设备上基于SOTA的高效NeRF方法的吞吐量瓶颈。我们发现：
    
    1. 常用的统一点采样方法和
    2. 嵌入所需的密集访问和计算
    
    是导致现有方法效率低下的主要原因。
    
- 我们提出了RT-NeRF，据我们所知，它是第一个用于加速NeRF的算法-硬件联合设计框架。具体来说，我们的RT-NeRF旨在通过开发定制的算法和硬件创新来解决上述瓶颈的低效率问题，这些算法和硬件创新利用了预先存在的点和特定网格的嵌入的稀疏性。因此，我们的RT-NeRF为实时NeRF解决方案开辟了一个令人兴奋的视角。
- 在算法层面上，通过利用预先存在的点的稀疏性，RT-NeRF整合了一个高效的渲染管道，通过直接计算预先存在的点的几何形状，基于占用网格的相应非零立方体，来缓解普遍采用的均匀点采样所带来的低效率。此外，在我们提出的渲染管道中，为了跳过预先存在的不可见的点以进一步提高效率，RT-NeRF利用了一个粗粒度的视图相关的渲染排序方案来避免处理不可见的点。
- 在硬件层面上，我们的RT-NeRF加速器采用了混合编码方案，为低（<80%）和高（≥80%）稀疏率的NeRF嵌入分别使用 bitmap 和 Coordinate-based sparsity encoding。这种混合方案是为了最大限度地节省存储空间，从而减少所需的DRAM访问，同时支持高效的解码，尽管NeRF嵌入的稀疏率各不相同（例如，4%∼92%）。此外，为了避免常见的由于稀疏解码导致的计算空闲，我们的RT-NeRF加速器同时集成了一个高密度稀疏查询单元和一个双向加法器和查询树，以协调上述两种编码格式，确保高效的稀疏解码。
- 在Synthetic-NeRF[17]的八个数据集上进行的基准实验和消融研究一致验证了RT-NeRF的有效性，例如，与SOTA高效的NeRF解决方案相比，实现了9.7倍∼3201倍的吞吐量改进，同时保持了类似的渲染质量

  

# Analyze Step

## L**ocate the pre-existing points**

如图3所示，为了定位预先存在的点，所有的候选点都沿射线均匀采样，然后通过基于占用网格的查询过程来确定预先存在的点的存在。从这个过程中，我们确定了两个冗余成本的来源。(1) 占用网格的稀疏性没有被利用，因此对占用网格的查询次数固定为 $𝐻×𝑊×𝑁$，无论占用网格中的值是多少，其中 $𝐻$ 和 $𝑊$ 分别代表要渲染的图像的高度和宽度，而 $𝑁$ 表示沿每个射线的采样点数量。(2) DRAM对占用网格的访问是不规则的，因为发射的光线可能来自任何方向，因此它们对占用网格的访问顺序无法事先预测。

### Proposed Solution

为了消除上述多余的计算和内存访问，我们提出了一个高效的NeRF管道，它通过循环占用网格的非零立方体而不是所有采样的候选点来直接计算预先存在的点的坐标。我们提出的管道的详细描述见第3.1节。

## C**ompute pre-existing points’ features**

如图4所示，对于步骤❷-②（即计算预先存在的点的特征），以矩阵-向量对的格式从分解的嵌入网格中查询嵌入所需的延迟要比使用MLP模型计算视图相关颜色的延迟高得多（例如，4 × ∼ 45 ×）。我们发现，这是因为矩阵-向量对被视为密集的矩阵和/或向量，尽管它们有很高的稀疏度（例如，高达92%的稀疏度），但还是造成了多余的计算和DRAM访问，如图5中所示。

### Proposed Solution

从上述计算预存点特征的步骤来看，我们发现相应的权重始终存在稀疏性，这些稀疏性的特点是不平衡的模式，并且与数据集有关，然而SOTA高效的NeRF解决方案并没有利用这些稀疏性。如图5所示，在不平衡的稀疏模式方面，我们可以观察到不同类型的权重的稀疏率从4%到92%不等；在与数据集相关的稀疏方面，同一类型的权重的稀疏率在不同的数据集上可以从46%到88%不等。为了利用上述的稀疏性来提高效率，我们提出了一种混合编码方案，用于矩阵和/或向量，分别针对低（<80%）和高（≥80%）稀疏率的情况自适应地采用基于位图或坐标的稀疏性编码格式，目的是最大限度地节省存储空间，从而减少所需的DRAM访问。此外，我们还提出了一个高密度的稀疏查询单元和一个双重用途的双向加法器和查询树，以协调上述两种编码格式，确保高效的稀疏解码。4.2.2节对所提出的混合编码方案、稀疏查询单元和加法&查询树进行了详细的描述。

# RT-NeRF: Proposed Algorithm

## **Efficient Rendering Pipeline**

为了减轻第2.2.1节中分析的步骤❷-①中普遍采用的均匀点取样（即定位预先存在的点）造成的冗余计算和内存访问，我们提出了一个高效的渲染管道，它只通过循环占用网格的非零立方体而不是所有取样的候选点来直接计算预先存在的点的几何图形。如图6所示，与文献[4]中的SOTA渲染管线相比，所提出的管线可以将访问占用网格的次数减少100×，同时也使相应的DRAM访问更有规律，即以固定的顺序循环访问占用网格中的非零立方体，而不是根据不可预测的射线方向随机访问网格。具体来说，建议的渲染管线包括：

- 步骤❷-①-a。将 Occupancy Grid 中的每个 Non-zero cube 近似为一个球，以方便后续步骤的计算；
- 步骤❷-①-b。将上述的球投射到要渲染的图像上，成为一个椭圆；
- 步骤 ❷-①-c。根据待渲染图像中点的规则排列，即一个点对应一个像素，确定椭圆内的点；
- 步骤❷-①-d：使用 Line-Sphere intersections 的解析解来计算出沿着光线射线并且在球内的点的 Geometries

因此，在我们设计的的渲染管道中，只有预先存在的点会被包含在循环中，而不是所有采样的候选点，解决了(1)忽略占用网格的稀疏性和(2)在SOTA渲染管道中需要不规则的DRAM访问的限制[4]，如第2.2.1节所分析。

![[02-论文笔记/NeuralRendering（神经渲染）/竞品：RT-NeRF/images/Untitled.png]]

The proposed rendering pipeline which directly computes the geometry of pre-existing points, enabling occupancy grid accesses that are both _fewer_ and _more regular_ than the SOTA rendering pipeline.

  

## **View-Dependent Rendering Ordering**

如第2.1节所述，early-ray-termination，可以从预先存在的点中过滤出不可见的点，已被广泛采用在SOTA高效的NeRF解决方案中。然而，将 early-ray-termination 应用于我们在第3.1节中提出的高效渲染管道并不简单。这是因为一个给定的点的可见度取决于离视图原点较近的点的特征，正如公式1所说明的，较低的累积透射率 $𝑇_𝑘$ 表示较低的可见度。因此，如果那些不可见但预先存在的点被首先访问，而相应的累积透射率仍然是未知的，则会导致步骤❷-②中存在多余的计算和数据访问（即计算预先存在的点的特征），因为缺乏比那些不可见的点更接近视图原点的特征。  
为了弥补上述差距，我们提出了一个粗粒度的与视图有关的渲染顺序。具体来说，如图7所示，首先将占位网格平铺成八个子空间，最接近目标视图原点的子空间中的非零立方体将提前进入步骤❷-①（即定位预先存在的点）。这样，离视图原点较近的点的特征会先被计算出来，这可以帮助确定离视图原点较远的点的可见性，从而可以防止对不可见点的处理。此外，这种首先定位的预存点也会提前进入步骤❷-②（即计算预存点的特征）。因此，在渲染过程中，只有公式1中最终渲染的颜色 $\mathbf{C}(\mathbf r)$ 的 Partial Sum 需要作为中间结果存储，与SOTA解决方案中所有预存点的查询特征不同。因此，所提出的粗粒度视图依赖的渲染顺序不仅可以防止在定位预先存在的点和计算预先存在的点的特征的步骤中对不可见的点进行不必要的计算和内存访问，而且还可以根据公式1减少步骤❸（即渲染像素的颜色）的内存访问，有效地加速了占渲染延迟99%以上的所有步骤，如图4所示。

![[02-论文笔记/NeuralRendering（神经渲染）/竞品：RT-NeRF/images/Untitled 1.png]]

The tiled sub-space (marked as yellow) that is closest to the origin of the target view o will be processed first during our rendering process based on the current target view.

# 实验结果

![[02-论文笔记/NeuralRendering（神经渲染）/竞品：RT-NeRF/images/Untitled 2.png]]